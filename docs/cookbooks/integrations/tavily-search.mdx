---
title: Search with Personal Context
description: "Blend Tavily's realtime results with personal context stored in Mem0."
---


<Snippet file="security-compliance.mdx" />

Imagine asking a search assistant for "coffee shops nearby" and instead of generic results, it shows remote-work-friendly cafes with great WiFi in your city because it remembers you mentioned working remotely before. Or when you search for "lunchbox ideas for kids" it knows you have a 7-year-old daughter and recommends peanut-free options that align with her allergy.

That's what we are going to build today, a Personalized Search Assistant powered by Mem0 for memory and [Tavily](https://tavily.com) for real-time search.


## Why Personalized Search

Most assistants treat every query like they've never seen you before. That means repeating yourself about your location, diet, or preferences, and getting results that feel generic.

- With Mem0, your assistant builds a memory of the user's world.
- With Tavily, it fetches fresh and accurate results in real time.

Together, they make every interaction smarter, faster, and more personal.

## Prerequisites

Before you begin, make sure you have:

1. Installed the dependencies:
```bash
npm install mem0ai @langchain/community @langchain/openai @langchain/core langchain
```

2. Set up your API keys in a .env file:
```bash
OPENAI_API_KEY=your-openai-key
TAVILY_API_KEY=your-tavily-key
MEM0_API_KEY=your-mem0-key
```

## Code Walkthrough
Let’s break down the main components.

### 1: Initialize Mem0 with Custom Instructions

We configure Mem0 with custom instructions that guide it to infer user memories tailored specifically for our usecase.

```typescript
import MemoryClient from 'mem0ai';

const mem0Client = new MemoryClient({ apiKey: process.env.MEM0_API_KEY! });

await mem0Client.project.update({
  customInstructions: `
INFER THE MEMORIES FROM USER QUERIES EVEN IF IT'S A QUESTION.

We are building personalized search for which we need to understand about user's preferences and life
and extract facts and memories accordingly.
`,
});
```
Now, if a user casually mentions "I need to pick up my daughter" or "What's the weather at Los Angeles", Mem0 remembers they have a daughter or the user is interested in or connected with Los Angeles in terms of location. These details will be referenced for future searches.

### 2. Simulating User History
To test personalization, we preload some sample conversation history for a user:

```typescript
async function setupUserHistory(userId: string) {
  const conversations = [
    [{ role: 'user', content: 'What will be the weather today at Los Angeles? I need to pick up my daughter from office.' },
     { role: 'assistant', content: "I'll check the weather in LA for you." }],
    [{ role: 'user', content: "I'm looking for vegan restaurants in Santa Monica" },
     { role: 'assistant', content: "I'll find great vegan options in Santa Monica." }],
    [{ role: 'user', content: 'My 7-year-old daughter is allergic to peanuts' },
     { role: 'assistant', content: "I'll remember to check for peanut-free options." }],
    [{ role: 'user', content: 'I work remotely and need coffee shops with good wifi' },
     { role: 'assistant', content: "I'll find remote-work-friendly coffee shops." }],
    [{ role: 'user', content: 'We love hiking and outdoor activities on weekends' },
     { role: 'assistant', content: "Great! I'll keep your outdoor activity preferences in mind." }],
  ];

  for (const conversation of conversations) {
    await mem0Client.add(conversation, { userId });
  }
}
```
This gives the agent a baseline understanding of the user’s lifestyle and needs.

### 3. Retrieving User Context from Memory
When a user makes a new search query, we retrieve relevant memories to enhance the search query:

```typescript
async function getUserContext(userId: string, query: string): Promise<string> {
  const userMemories = await mem0Client.search(query, { filters: { user_id: userId } });

  if (userMemories && userMemories.results.length > 0) {
    return userMemories.results.map((m: any) => `- ${m.memory}`).join('\n');
  }
  return 'No previous user context available.';
}
```
This context is injected into the search agent so results are personalized.

### 4. Creating the Personalized Search Agent
The agent uses Tavily search, but always augments search queries with user context:

```typescript
import { TavilySearch } from '@langchain/community/tools/tavily_search';
import { ChatOpenAI } from '@langchain/openai';
import { ChatPromptTemplate, MessagesPlaceholder } from '@langchain/core/prompts';
import { AgentExecutor, createOpenAIToolsAgent } from 'langchain/agents';
import { HumanMessage } from '@langchain/core/messages';

const llm = new ChatOpenAI({ model: 'gpt-4o-mini', apiKey: process.env.OPENAI_API_KEY });

function createPersonalizedSearchAgent(userContext: string): AgentExecutor {
  const tavilySearch = new TavilySearch({
    maxResults: 10,
    searchDepth: 'advanced',
    includeAnswer: true,
    topic: 'general',
  });

  const tools = [tavilySearch];

  const prompt = ChatPromptTemplate.fromMessages([
    ['system', `You are a personalized search assistant.

USER CONTEXT AND PREFERENCES:
${userContext}

YOUR ROLE:
1. Analyze the user's query and context.
2. Enhance the query with relevant personal memories.
3. Always use tavily_search for results.
4. Explain which memories influenced personalization.`],
    new MessagesPlaceholder('messages'),
    new MessagesPlaceholder('agent_scratchpad'),
  ]);

  const agent = createOpenAIToolsAgent({ llm, tools, prompt });
  return AgentExecutor.fromAgentAndTools({ agent, tools, verbose: true, returnIntermediateSteps: true });
}
```

### 5. Run a Personalized Search
The workflow ties everything together:

```typescript
async function conductPersonalizedSearch(userId: string, query: string) {
  const userContext = await getUserContext(userId, query);
  const agentExecutor = createPersonalizedSearchAgent(userContext);

  const response = await agentExecutor.invoke({
    messages: [new HumanMessage(query)],
  });
  return { agentResponse: response.output };
}
```

### 6. Store New Interactions
Every new query/response pair is stored for future personalization:

```typescript
async function storeSearchInteraction(userId: string, originalQuery: string, agentResponse: string) {
  const interaction = [
    { role: 'user', content: `Searched for: ${originalQuery}` },
    { role: 'assistant', content: `Results based on preferences: ${agentResponse}` },
  ];
  await mem0Client.add(interaction, { userId });
}
```

### Full Example Run

```typescript
const userId = 'john';
await setupUserHistory(userId);

const queries = [
  'good coffee shops nearby for working',
  'what can I make for my kid in lunch?',
];

for (const q of queries) {
  const results = await conductPersonalizedSearch(userId, q);
  console.log(`\nQuery: ${q}`);
  console.log(`Personalized Response: ${results.agentResponse}`);
}
```

## How It Works in Practice

Here's how personalization plays out:

- **Context Gathering**: User previously mentioned living in Los Angeles, being vegan, and having a 7-year-old daughter allergic to peanuts.
- **Enhanced Search Query**:
  - Query: "good coffee shops nearby for working"
  - Enhanced Query: "good coffee shops in Los Angeles with strong WiFi, remote-work-friendly"
- **Personalized Results**: The assistant only returns WiFi-friendly, work-friendly cafes near Los Angeles.
- **Memory Update**: Interaction is saved for better future recommendations.

## Conclusion

With Mem0 and Tavily, you can build a search assistant that doesn't just fetch results but understands the person behind the query.

Whether for shopping, travel, or daily life, this approach turns a generic search into a truly personalized experience.

Full Code: [Personalized Search GitHub](https://github.com/mem0ai/mem0/blob/main/examples/misc/personalized_search.py)

---

<CardGroup cols={2}>
  <Card title="Deep Research with Mem0" icon="magnifying-glass" href="/cookbooks/operations/deep-research">
    Build comprehensive research agents that remember findings across sessions.
  </Card>
  <Card title="Tag and Organize Memories" icon="tag" href="/cookbooks/essentials/tagging-and-organizing-memories">
    Categorize search results and user preferences for better personalization.
  </Card>
</CardGroup>
