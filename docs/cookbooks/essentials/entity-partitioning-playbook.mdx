---
title: Partition Memories by Entity
description: Keep memories separate by tagging each write and query with user, agent, app, and session identifiers.
---

Nora runs a travel service. When she stored all memories in one bucket, a recruiter's nut allergy accidentally appeared in a traveler's dinner reservation. Let's fix this by properly separating memories for different users, agents, and applications.

<Info icon="clock">
**Time to complete:** ~15 minutes · **Languages:** TypeScript
</Info>

## Setup

```typescript
import MemoryClient from 'mem0ai';

const client = new MemoryClient({ apiKey: 'm0-...' });
```

Grab an API key from the <Link href="https://app.mem0.ai/">Mem0 dashboard</Link> to get started.

## Store and Retrieve Scoped Memories

Let's start by storing Cam's travel preferences and retrieving them:

```typescript
const camMessages = [
  { role: 'user', content: "I'm Cam. Keep in mind I avoid shellfish and prefer boutique hotels." },
  { role: 'assistant', content: "Noted! I'll use those preferences in future itineraries." }
];

const result = await client.add(camMessages, {
  userId: 'traveler_cam',
  agentId: 'travel_planner',
  runId: 'tokyo-2025-weekend',
  appId: 'concierge_app',
});
```

The memory is now stored. Let's retrieve those memories with the same identifiers:

```typescript
const userScope = {
  AND: [
    { userId: 'traveler_cam' },
    { appId: 'concierge_app' },
    { runId: 'tokyo-2025-weekend' }
  ]
};
const userMemories = await client.search('Any dietary restrictions?', { filters: userScope });
console.log(userMemories);

const agentScope = {
  AND: [
    { agentId: 'travel_planner' },
    { appId: 'concierge_app' }
  ]
};
const agentMemories = await client.search('Any dietary restrictions?', { filters: agentScope });
console.log(agentMemories);
```

**Output:**
```
{'results': [{'memory': 'avoids shellfish and prefers boutique hotels', ...}]}
{'results': [{'memory': 'avoids shellfish and prefers boutique hotels', ...}]}
```

<Tip icon="compass">
Memories can be written with several identifiers, but each search resolves one entity boundary at a time. Run separate queries for user and agent scopes—just like above—rather than combining both in a single filter.
</Tip>

## When Memories Leak

When Nora adds a chef agent, Cam's travel preferences leak into food recommendations:

```typescript
const chefFilters = { AND: [{ userId: 'traveler_cam' }] };

const collision = await client.search('What should I cook?', { filters: chefFilters });
console.log(collision);
```

**Output:**
```
['avoids shellfish and prefers boutique hotels', 'prefers Kyoto kaiseki dining experiences']
```

The travel preferences appear because we only filtered by `user_id`. The chef agent shouldn't see hotel preferences.

## Fix the Leak with Proper Filters

First, let's add a memory specifically for the chef agent:

```typescript
const chefMemory = [
  { role: 'user', content: "I'd like to try some authentic Kyoto cuisine." },
  { role: 'assistant', content: "I'll remember that you prefer Kyoto kaiseki dining experiences." }
];

await client.add(chefMemory, {
  userId: 'traveler_cam',
  agentId: 'chef_recommender',
  runId: 'menu-planning-2025-04',
  appId: 'concierge_app',
});
```

Now search within the chef's scope:

```typescript
const safeFilters = {
  AND: [
    { agentId: 'chef_recommender' },
    { appId: 'concierge_app' },
    { runId: 'menu-planning-2025-04' }
  ]
};

const chefMemories = await client.search('Any food alerts?', { filters: safeFilters });
console.log(chefMemories);
```

**Output:**
```
{'results': [{'memory': 'prefers Kyoto kaiseki dining experiences', ...}]}
```

Now the chef agent only sees its own food preferences. The hotel preferences stay with the travel agent.

## Separate Apps with app_id

Nora white-labels her travel service for a sports brand. Use `app_id` to keep enterprise data separate:

```typescript
const enterpriseFilters = {
  AND: [
    { appId: 'sports_brand_portal' },
    { userId: '*' },
    { agentId: '*' }
  ]
};

const page = await client.getAll({ filters: enterpriseFilters, page: 1, pageSize: 10 });
console.log(page['results'].map((row: any) => row['userId']));
```

**Output:**
```
['athlete_jane', 'coach_mike', 'team_admin']
```

<Info>
Wildcards (`"*"` ) only match non-null values. Make sure you write memories with explicit `app_id` values.
</Info>

<Tip icon="sparkles">
Need a deeper tour of AND vs OR, nested filters, or wildcard tricks? Check the <Link href="/platform/features/v2-memory-filters">Memory Filters v2 guide</Link> for full examples you can copy into this flow.
</Tip>

When the sports brand offboards, delete all their data:

```typescript
await client.deleteAll({ appId: 'sports_brand_portal' });
```

**Output:**
```
{'message': 'Memories deleted successfully!'}
```

## Production Patterns

```typescript
// Nightly audits - check all data for an app
async function auditApp(appId: string) {
  const filters = { AND: [{ appId }, { userId: '*' }, { agentId: '*' }] };
  return client.getAll({ filters, page: 1, pageSize: 50 });
}

// Session cleanup - delete temporary conversations
async function closeTicket(ticketId: string, userId: string) {
  await client.deleteAll({ userId, runId: ticketId });
}

// Compliance exports - get all data for one tenant
const exportData = await client.getMemoryExport({ filters: { AND: [{ appId: 'sports_brand_portal' }] } });
```

## Complete Example

Putting it all together - here's how to properly scope memories:

```typescript
// Store memories with all identifiers
await client.add(
  [{ role: 'user', content: 'I need a hotel near the conference center.' }],
  {
    userId: 'exec_123',
    agentId: 'booking_assistant',
    appId: 'enterprise_portal',
    runId: 'trip-2025-03',
  }
);

// Retrieve with the same scope
const filters = {
  AND: [
    { userId: 'exec_123' },
    { appId: 'enterprise_portal' },
    { runId: 'trip-2025-03' }
  ]
};

// Alternative: Use wildcards if you're not sure about some fields
// const filters = {
//   AND: [
//     { userId: 'exec_123' },
//     { agentId: '*' },  // Match any agent
//     { appId: 'enterprise_portal' },
//     { runId: '*' }      // Match any run
//   ]
// };

const results = await client.search('Hotels near conference', { filters });

// Debug: Print the filter you're using
console.log('Searching with filters:', filters);

// If no results, try a broader search to see what's stored
if (!results['results'].length) {
  console.log('No results found! Trying broader search...');
  const broader = await client.getAll({ filters: { userId: 'exec_123' } });
  console.log(broader);
}

console.log(results['results'][0]['memory']);
```

**Output:**
```
I need a hotel near the conference center.
```

## When to Use Each Identifier

| Identifier | When to Use | Example Values |
|------------|-------------|----------------|
| `user_id` | Individual preferences that persist across all interactions | `cam_traveler`, `sarah_exec`, `team_alpha` |
| `agent_id` | Different AI roles need separate context | `travel_agent`, `concierge`, `customer_support` |
| `app_id` | White-label deployments or separate products | `travel_app_ios`, `enterprise_portal`, `partner_integration` |
| `run_id` | Temporary sessions that should be isolated | `support_ticket_9234`, `chat_session_456`, `booking_flow_789` |

## Troubleshooting Common Issues

### My search returns empty results!

**Problem**: Using `AND` with exact matches but some fields might be `null`.

**Solution**:
```typescript
// If this returns nothing:
let filters = { AND: [{ userId: 'u1' }, { agentId: 'a1' }] };

// Try using wildcards:
filters = { AND: [{ userId: 'u1' }, { agentId: '*' }] };

// Or don't include fields you don't need:
filters = { AND: [{ userId: 'u1' }] };
```

### OR gives results but AND doesn't

This confirms you have a **field mismatch**. The memory exists but some identifier values don't match exactly.

**Always check what's actually stored:**
```typescript
// Get all memories for the user to see the actual field values
const allMems = await client.getAll({ filters: { userId: 'your_user_id' } });
console.log(JSON.stringify(allMems, null, 2));
```

## Best Practices

1. **Use consistent identifier formats**
   ```typescript
   // Good: consistent patterns
   const userId = 'cam_traveler';
   const agentId = 'travel_agent_v1';
   const appId = 'nora_concierge_app';
   const runId = 'tokyo_trip_2025_03';

   // Avoid: mixed patterns
   // userId = '123', agentId = 'agent2', appId = 'app'
   ```

2. **Print filters when debugging**
   ```typescript
   const filters = { AND: [{ userId: 'cam', agentId: 'chef' }] };
   console.log('Searching with filters:', filters);  // Helps catch typos
   ```

3. **Clean up temporary sessions**
   ```typescript
   // After a support ticket closes
   await client.deleteAll({ userId: 'customer_123', runId: 'ticket_456' });
   ```

## Summary

You learned how to:
- Store memories with proper entity scoping using `user_id`, `agent_id`, `app_id`, and `run_id`
- Prevent memory leaks between different agents and applications
- Clean up data for specific tenants or sessions
- Use wildcards to query across scoped memories

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Deep Dive: Memory Filters v2"
    description="Layer entity filters with JSON logic to answer complex queries."
    icon="sliders"
    href="/platform/features/v2-memory-filters"
  />
  <Card
    title="Control Memory Ingestion"
    description="Pair scoped storage with rules that block low-quality facts."
    icon="shield-check"
    href="/cookbooks/essentials/controlling-memory-ingestion"
  />
</CardGroup>
