---
title: Set Memory Expiration
description: "Define short-term versus long-term retention so the store stays fresh."
---


While building memory systems, we realized their size grows fast. Session notes, temporary context, chat history - everything starts accumulating and bogging down the system. This pollutes search results and increase storage costs. Not every memory needs to persist forever.

In this cookbook, we'll go through how to use short-term vs long-term memories and see where it's best to use them.

---

## Overview

By default, Mem0 memories persist forever. This works for user preferences and core facts, but temporary data should expire automatically.

In this tutorial, we will:

- Understand default (permanent) memory behavior
- Add expiration dates for temporary memories
- Decide what should be temporary vs permanent

---

## Setup

```typescript
import MemoryClient from 'mem0ai';

const client = new MemoryClient({ apiKey: 'your-api-key' });
```

<Note>
No special date imports needed in TypeScript — use `new Date()` and `Date.now()` to calculate expiration dates.
</Note>

---

## Default Behavior: Everything Persists

By default, all memories persist forever:

```typescript
// Store user preference
await client.add('User prefers dark mode', { userId: 'sarah' });

// Store session context
await client.add('Currently browsing electronics category', { userId: 'sarah' });

// 6 months later - both still exist
const results = await client.getAll({ filters: { userId: 'sarah' } });
console.log(`Total memories: ${results['results'].length}`);
```

**Output:**

```
Total memories: 2

```

Both the preference and session context persist. The preference is useful, but the 6-month-old session context is not.

---

## The Problem: Memory Bloat

Without expiration, memories accumulate forever. Session notes from weeks ago mix with current preferences. Storage grows, search results get polluted with irrelevant old context, and retrieval quality degrades.

<Warning>
Memory bloat degrades search quality. When "User prefers dark mode" competes with "Currently browsing electronics" from 6 months ago, semantic search returns stale session data instead of actual preferences. Old memories pollute retrieval.
</Warning>

---

## Short-Term Memories: Adding Expiration

Set `expiration_date` to make memories temporary:

```typescript
// Session context - expires in 7 days
const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();

await client.add(
  'Currently browsing electronics category',
  { userId: 'sarah', expirationDate: expiresAt }
);

// User preference - no expiration, persists forever
await client.add(
  'User prefers dark mode',
  { userId: 'sarah' }
);
```

<Info icon="check">
**Expected behavior:** After 7 days, the session context automatically disappears—no cron jobs, no manual cleanup. The preference persists forever. Mem0 handles expiration transparently.
</Info>

Memories with `expiration_date` are automatically removed after expiring. No cleanup job needed - Mem0 handles it.

<Tip>
Start conservative with short expiration windows (7 days), then extend them based on usage patterns. It's easier to increase retention than to clean up over-retained stale data. Monitor search quality to find the right balance.
</Tip>

---

## When to Use Each

### Permanent Memories (no expiration_date):

**Use for:**

- User preferences and settings
- Account information
- Important facts and milestones
- Historical data that matters long-term

```typescript
await client.add('User prefers email notifications', { userId: 'sarah' });
await client.add("User's birthday is March 15th", { userId: 'sarah' });
await client.add('User completed onboarding on Jan 5th', { userId: 'sarah' });
```

### Temporary Memories (with expiration_date):

**Use for:**

- Session context (current page, browsing history)
- Temporary reminders
- Recent chat history
- Cached data

```typescript
const expires7d = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();

await client.add(
  'Currently viewing product ABC123',
  { userId: 'sarah', expirationDate: expires7d }
);

await client.add(
  'Asked about return policy',
  { userId: 'sarah', expirationDate: expires7d }
);
```

---

## Setting Different Expiration Periods

Different data needs different lifetimes:

```typescript
// Session context - 7 days
const expires7d = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();
await client.add('Browsing electronics', { userId: 'sarah', expirationDate: expires7d });

// Recent chat - 30 days
const expires30d = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString();
await client.add('User asked about warranty', { userId: 'sarah', expirationDate: expires30d });

// Important preference - no expiration
await client.add('User prefers dark mode', { userId: 'sarah' });
```

---

## Using Metadata to Track Memory Types

Tag memories to make filtering easier:

```typescript
const expires7d = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();

// Tag session context
await client.add(
  'Browsing electronics',
  { userId: 'sarah', expirationDate: expires7d, metadata: { type: 'session' } }
);

// Tag preference
await client.add(
  'User prefers dark mode',
  { userId: 'sarah', metadata: { type: 'preference' } }
);

// Query only preferences
const preferences = await client.getAll({
  filters: {
    AND: [
      { userId: 'sarah' },
      { metadata: { type: 'preference' } }
    ]
  }
});
```

---

## Checking Expiration Status

See which memories will expire and when:

```typescript
const results = await client.getAll({ filters: { userId: 'sarah' } });

for (const memory of results['results']) {
  const expDate = memory['expiration_date'];

  if (expDate) {
    console.log(`Temporary: ${memory['memory']}`);
    console.log(`  Expires: ${expDate}\n`);
  } else {
    console.log(`Permanent: ${memory['memory']}\n`);
  }
}
```

**Output:**

```
Temporary: Browsing electronics
  Expires: 2025-11-01T10:30:00Z

Temporary: Viewed MacBook Pro and Dell XPS
  Expires: 2025-11-01T10:30:00Z

Permanent: User prefers dark mode

Permanent: User prefers email notifications

```

---

## What You Built

A self-cleaning memory system with automatic retention policies:

- **Automatic expiration** - Memories self-destruct after defined periods, no cron jobs needed
- **Tiered retention** - 7-day session context, 30-day chat history, permanent preferences
- **Metadata tagging** - Classify memories by type (session, preference, chat) for filtered retrieval
- **Expiration tracking** - Check which memories will expire and when using `get_all()`

This pattern keeps storage costs low and search quality high as your memory store scales.

---

## Summary

Memory expiration keeps storage clean and search results relevant. Use **`expiration_date`** for temporary data (session context, recent chats), skip it for permanent facts (preferences, account info). Mem0 handles cleanup automatically—no background jobs required.

Start by identifying what's temporary versus permanent, then set conservative expiration windows and adjust based on retrieval quality.

<CardGroup cols={2}>
  <Card title="Control Memory Ingestion" icon="filter" href="/cookbooks/essentials/controlling-memory-ingestion">
    Pair expirations with ingestion rules so only trusted context persists.
  </Card>
  <Card title="Export Memories Safely" icon="download" href="/cookbooks/essentials/exporting-memories">
    Build compliant archives once your retention windows are dialed in.
  </Card>
</CardGroup>
