---
title: Control Memory Ingestion
description: "Filter speculation, enforce formats, and gate low-confidence data before it persists."
---


AI assistants plugged with memory systems face a problem - they often store everything. Not every conversation needs to be remembered, and not every detail should go to the memory store. Without proper controls, memory systems accumulate unreliable data.

Mem0 lets you control your memory ingestion pipeline. In this cookbook, we'll demonstrate these controls using a medical assistant example - showing how to filter unwanted data, enforce data formats, and implement confidence-based storage.

---

## Overview

Without controls, everything gets stored - speculation, low-confidence data, and information that shouldn't persist. This uncontrolled ingestion leads to cluttered memory and retrieval failures.

Mem0 provides **three tools to control** what gets stored:

1. **Custom instructions** define what to remember and what to ignore.
2. **Confidence thresholds** ensure only verified facts persist.
3. **Memory updates** let you change information without creating duplicates.

In this tutorial, we will:

- Filter speculative statements with custom instructions
- Configure confidence thresholds for fact verification
- Update stored information without duplication
- Build a complete ingestion pipeline

---

## Setup

```typescript
import MemoryClient from 'mem0ai';

const client = new MemoryClient({ apiKey: 'your-api-key' });
```

<Note>
Replace `your-api-key` with your actual Mem0 API key from the [dashboard](https://app.mem0.ai). Without proper API authentication, memory operations will fail.
</Note>

---

## The Problem

Uncontrolled ingestion stores everything, including speculation:

```typescript
// Patient mentions speculation
const messages = [{ role: 'user', content: 'I think I might be allergic to penicillin' }];
await client.add(messages, { userId: 'patient_123' });

// Check what got stored
const results = await client.search('patient allergies', { filters: { AND: [{ userId: 'patient_123' }] } });
console.log(results['results'][0]['memory']);
```

**Output:**

```
Patient is allergic to penicillin
```

<Warning>
Without custom instructions, AI assistants treat speculation as confirmed facts. "I think I might be allergic" becomes "Patient is allergic"—a dangerous transformation in sensitive domains like healthcare, legal, or financial services.
</Warning>

The speculation became a confirmed fact. Let's add controls.

---

## Custom Instructions

Custom instructions tell Mem0 what to store and what to ignore.

```typescript
const instructions = `
Only store CONFIRMED medical facts.

Store:
- Confirmed diagnoses from doctors
- Known allergies with documented reactions
- Current medications being taken

Ignore:
- Speculation (words like "might", "maybe", "I think")
- Unverified symptoms
- Casual mentions without confirmation
\`;

// Configure via Mem0 dashboard: app.mem0.ai/settings
// await (client as any).project?.update({ customInstructions: instructions });

// Same speculative statement
const messages = [{ role: 'user', content: 'I think I might be allergic to penicillin' }];
await client.add(messages, { userId: 'patient_123' });

// Check what got stored
const results = await client.getAll({ filters: { AND: [{ userId: 'patient_123' }] } });
console.log(`Memories stored: ${results['results'].length}`);

```

**Output:**

```
Memories stored: 0
```

<Info>
**Expected output:** Zero memories stored. The speculative statement "I think I might be allergic" was filtered out before reaching storage. Custom instructions are actively blocking unreliable data.
</Info>

The speculation was filtered out.

---

## Designing Custom Instructions

When designing instructions, consider the trade-off between precision and recall:

**Too restrictive:** You'll miss important information (false negatives)

```typescript
// Too strict - filters out useful context
/*
Only store information if explicitly stated by a doctor with full name,
date, time, and medical license number.
*/
```

**Too permissive:** You'll store unreliable data (false positives)

```typescript
// Too loose - stores speculation as fact
/*
Store any health-related information mentioned.
*/
```

**Balanced approach:**

```typescript
// Clear categories with examples
/*
Store CONFIRMED facts:
- Diagnoses: "Dr. Smith diagnosed hypertension on March 15th"
- Allergies: "Patient had hives reaction to penicillin"
- Medications: "Taking Lisinopril 10mg daily"

Ignore SPECULATION:
- "I think I might have..."
- "Maybe it's..."
- "Could be related to..."
*/
```

<Tip>
Start with strict instructions (only store confirmed facts), then relax them based on your use case. It's easier to allow more data than to clean up polluted memory. Test with sample conversations before deploying to production.
</Tip>

Start with clear categories and iterate based on retrieval quality.

---

## Confidence Thresholds

Mem0 assigns confidence scores to extracted memories. Use these to filter low-quality data.

### Setting Thresholds

Setting the right confidence threshold depends on your application:

- **High-stakes domains** (medical, legal): Require 0.8+ confidence
- **General assistants**: 0.6+ confidence is often sufficient
- **Exploratory systems**: Lower thresholds (0.4+) capture more data

Test your pipeline with multiple input examples and threshold combinations to find what works for your use case.

```typescript
// Configure stricter instructions
// Configure via Mem0 dashboard: app.mem0.ai/settings
// await (client as any).project?.update({
//   customInstructions: `
// Only extract memories with HIGH confidence.
// Require specific details (dates, dosages, doctor names) for medical facts.
// Skip vague or uncertain statements.
// `
// });

// Test with uncertain statement
let messages = [{ role: 'user', content: 'The doctor mentioned something about my blood pressure' }];
const result1 = await client.add(messages, { userId: 'patient_123' });

// Test with confirmed fact
messages = [{ role: 'user', content: 'Dr. Smith diagnosed me with hypertension on March 15th' }];
const result2 = await client.add(messages, { userId: 'patient_123' });

console.log('Vague statement stored:', result1['results'].length > 0);
console.log('Confirmed fact stored:', result2['results'].length > 0);
```

**Output:**

```
Vague statement stored: False
Confirmed fact stored: True
```

<Info icon="check">
**Expected behavior:** Low-confidence extractions are now filtered out automatically. Only verified facts with specific details (names, dates, dosages) persist in memory. The confidence threshold is working.
</Info>

The vague statement was filtered for low confidence. The confirmed fact with specific details was stored.

---

## Filtering Sensitive Information

Custom instructions can prevent storing personal identifiers:

```typescript
// Configure via Mem0 dashboard: app.mem0.ai/settings
// await (client as any).project?.update({
//   customInstructions: `
// Medical memory rules:
//
// STORE:
// - Confirmed diagnoses
// - Verified allergies
// - Current medications
//
// NEVER STORE:
// - Social Security Numbers
// - Insurance policy numbers
// - Credit card information
// - Full addresses
// - Phone numbers
//
// Replace identifiers with generic references if mentioned.
// `
// });

// Test with PII
const messages = [
  { role: 'user', content: "My SSN is 123-45-6789 and I'm allergic to penicillin" }
];
await client.add(messages, { userId: 'patient_123' });

// Check what was stored
const results = await client.getAll({ filters: { AND: [{ userId: 'patient_123' }] } });
for (const result of results['results']) {
  console.log(result['memory']);
}
```

**Output:**

```
Patient is allergic to penicillin
```

The SSN was filtered out, but the allergy was stored.

---

## Updating Memories

When information changes, update existing memories instead of creating duplicates.

```typescript
// Initial allergy stored
const result = await client.add(
  [{ role: 'user', content: 'Patient confirmed allergy to penicillin with documented hives reaction' }],
  { userId: 'patient_123' }
);

const memoryId = result['results'][0]['id'];
console.log(`Stored memory: ${memoryId}`);

// Later, patient gets retested - allergy was false positive
await client.update(
  memoryId,
  'Patient tested negative for penicillin allergy on April 2nd, 2025. Previous allergy was false positive.',
  { metadata: { verified: true, updatedDate: '2025-04-02' } }
);

// Retrieve the updated memory
const updated = await client.get(memoryId);
console.log(`\nUpdated memory: ${updated['memory']}`);
console.log(`Metadata: ${JSON.stringify(updated['metadata'])}`);
```

**Output:**

```
Stored memory: mem_abc123

Updated memory: Patient tested negative for penicillin allergy on April 2nd, 2025. Previous allergy was false positive.
Metadata: {'verified': True, 'updated_date': '2025-04-02'}

```

### Benefits of Updating

**Preserves history:**

- `created_at` shows when the memory was first stored
- `updated_at` shows when it was modified
- Audit trail for compliance

**Avoids conflicts:**

- No duplicate or contradicting memories
- Single source of truth for each fact

<Warning>
That “no duplicates” promise comes from the inference pipeline. Keep `infer=True` when you rely on automatic updates. Raw imports (`infer=False`) skip conflict checks, so mixing the two modes for the same fact will create duplicates.
</Warning>

**Maintains relationships:**

- If using graph memory, connections to other entities persist

### Pick the right inference mode

| Mode | What it does | Best for | Watch out for |
| --- | --- | --- | --- |
| `infer=True` *(default)* | Runs the LLM pipeline so Mem0 extracts structured facts and resolves conflicts automatically. | Daily conversations, preference tracking, anything you want deduped. | Slightly slower because inference runs on every write. |
| `infer=False` | Stores your payload exactly as-is—no inference, no dedupe. | Bulk imports, compliance snapshots, curated facts you already trust. | Later `infer=True` calls for the same fact will create duplicates you must clean manually. |

<Tip>
Stay consistent per data source. If you need both behaviors, keep them in separate scopes (e.g., different `app_id` or `run_id`) so you always know which memories are inferred vs direct imports.
</Tip>

---

## Update vs Delete

When should you update vs delete?

### Update when:

- Information changes but remains relevant
- You need audit history
- The memory has relationships to other data

```typescript
// Medication dosage changed
await client.update(
  medId,
  'Taking Lisinopril 20mg daily (increased from 10mg on March 1st)'
);
```

### Delete when:

- Information was completely wrong
- Memory is no longer relevant
- Duplicate entry

```typescript
// Duplicate entry
await client.delete(memoryId);
```

---

## Putting It Together

Here's a complete ingestion pipeline with all controls:

```typescript
import MemoryClient from 'mem0ai';

// Initialize client
const client = new MemoryClient({ apiKey: process.env.MEM0_API_KEY! });

// Configure custom instructions via Mem0 dashboard: app.mem0.ai/settings
// await (client as any).project?.update({
//   customInstructions: `
// Medical memory assistant rules:
//
// STORE:
// - Confirmed diagnoses (with doctor name and date)
// - Verified allergies (with reaction details)
// - Current medications (with dosage)
//
// IGNORE:
// - Speculation (might, maybe, possibly)
// - Unverified symptoms
// - Personal identifiers (SSN, insurance numbers)
//
// CONFIDENCE:
// Require high confidence. Reject vague or uncertain statements.
// Require specific details: names, dates, dosages.
// `
// });

// Helper function for safe ingestion
async function addMedicalMemory(content: string, userId: string, metadata: Record<string, any> = {}) {
  const result = await client.add(
    [{ role: 'user', content }],
    { userId, metadata }
  );

  if (result['results'].length > 0) {
    console.log(`✓ Stored: ${result['results'][0]['memory']}`);
  } else {
    console.log(`✗ Filtered: ${content}`);
  }

  return result;
}

// Test cases
console.log('Testing ingestion pipeline:\n');

const testCases = [
  'I think I might be allergic to penicillin',
  'Dr. Johnson confirmed penicillin allergy on Jan 15th with hives reaction',
  'Patient SSN is 123-45-6789',
  'Currently taking Lisinopril 10mg daily for hypertension',
  'Feeling tired lately',
  'Dr. Martinez diagnosed Type 2 diabetes on February 3rd, 2025'
];

for (const content of testCases) {
  await addMedicalMemory(content, 'patient_123');
  console.log();
}
```

**Output:**

```
Testing ingestion pipeline:

✗ Filtered: I think I might be allergic to penicillin

✓ Stored: Patient has confirmed penicillin allergy diagnosed by Dr. Johnson on January 15th with hives reaction

✗ Filtered: Patient SSN is 123-45-6789

✓ Stored: Patient is currently taking Lisinopril 10mg daily for hypertension

✗ Filtered: Feeling tired lately

✓ Stored: Patient diagnosed with Type 2 diabetes by Dr. Martinez on February 3rd, 2025

```

---

## Per-Call Instructions

You can override project-level instructions for specific conversations:

First define custom instructions

```typescript
const customInstructions = `Emergency intake mode: Store ALL symptoms and observations immediately.
Flag for later review and verification.`;
```

```typescript
// Emergency intake - store everything temporarily
const emergencyMessages = [
  { role: 'user', content: 'Patient arrived with chest pain and shortness of breath' }
];

await client.add(
  emergencyMessages,
  {
    userId: 'patient_456',
    customInstructions,
    metadata: { type: 'emergency', reviewRequired: true }
  }
);
```

This is useful for:

- Different conversation types (emergency vs routine)
- Channel-specific rules (phone vs in-person)
- Temporary data collection that needs review

---

## What You Built

You now have a medical assistant with production-grade memory controls:

- **Custom instructions** - Filter speculation and enforce confirmed facts only
- **Confidence thresholds** - Gate extractions below 0.7 confidence score
- **Memory updates** - Modify stored information without creating duplicates
- **Per-call instructions** - Apply temporary rules for specific conversations
- **PII filtering** - Block sensitive data (SSNs, insurance numbers) automatically

These controls prevent retrieval failures and ensure your AI assistant works with reliable, verified information.

---

## Summary

Start with conservative filters (only store confirmed facts) and iterate based on your application's needs. Combine custom instructions with confidence thresholds for the most reliable memory ingestion pipeline.

<CardGroup cols={2}>
  <Card title="Expire Short-Term Data" icon="timer" href="/cookbooks/essentials/memory-expiration-short-and-long-term">
    Automatically clean up session context before it clutters retrieval.
  </Card>
  <Card title="Choose Your Memory Architecture" icon="sitemap" href="/cookbooks/essentials/choosing-memory-architecture-vector-vs-graph">
    Learn when to layer graph memory alongside vectors for multi-hop queries.
  </Card>
</CardGroup>
