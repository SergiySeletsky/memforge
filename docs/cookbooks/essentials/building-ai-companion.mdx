---
title: Build a Companion with Mem0
description: "Spin up a fitness coach that remembers goals, adapts tone, and keeps sessions personal."
---


Essentially, creating a companion out of LLMs is as simple as a loop. But these loops work great for one type of character without personalization and fall short as soon as you restart the chat.

Problem: LLMs are stateless. GPT doesn't remember conversations. You could stuff everything inside the context window, but that becomes slow, expensive, and breaks at scale.

The solution: Mem0. It extracts and stores what matters from conversations, then retrieves it when needed. Your companion remembers user preferences, past events, and history.

In this cookbook we'll build a **fitness companion** that:

- Remembers user goals across sessions
- Recalls past workouts and progress
- Adapts its personality based on user preferences
- Handles both short-term context (today's chat) and long-term memory (months of history)

By the end, you'll have a working fitness companion and know how to handle common production challenges.

---

## The Basic Loop with Memory

Max wants to train for a marathon. He starts chatting with Ray, an AI running coach.

```typescript
import OpenAI from 'openai';
import MemoryClient from 'mem0ai';

const openaiClient = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const mem0Client = new MemoryClient({ apiKey: process.env.MEM0_API_KEY! });

async function chat(userInput: string, userId: string): Promise<string> {
  // Retrieve relevant memories
  const memoriesResult = await mem0Client.search(userInput, { userId, limit: 5 });
  const context = memoriesResult.results.map((m: any) => m.memory).join('\n');

  // Call LLM with memory context
  const response = (await openaiClient.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      { role: 'system', content: `You're Ray, a running coach. Memories:\n${context}` },
      { role: 'user', content: userInput },
    ],
  })).choices[0].message.content ?? '';

  // Store the exchange
  await mem0Client.add([
    { role: 'user', content: userInput },
    { role: 'assistant', content: response },
  ], { userId });

  return response;
}
```

**Session 1:**

```typescript
await chat('I want to run a marathon in under 4 hours', 'max');
// Output: "That's a solid goal. What's your current weekly mileage?"
// Stored in Mem0: "Max wants to run sub-4 marathon"
```

**Session 2 (next day, app restarted):**

```typescript
await chat('What should I focus on today?', 'max');
// Output: "Based on your sub-4 marathon goal, let's work on building your aerobic base..."
```

<Info>
Ray remembers Max's goal across sessions. The app restarted, but the memory persisted. This is the core pattern: retrieve memories, pass them as context, store new exchanges.
</Info>

Ray remembers. Restart the app, and the goal persists. From here on, we'll focus on just the Mem0 API calls.

---

## Organizing Memory by Type

### Separating Temporary from Permanent

Max mentions his knee hurts. That's different from his marathon goal - one is temporary, the other is long-term.

**Categories vs Metadata:**

- **Categories**: AI-assigned by Mem0 based on content (you can't force them)
- **Metadata**: Manually set by you for forced tagging

Define custom categories at the project level. Mem0 will automatically tag memories with relevant categories based on content:

```typescript
await mem0Client.project.update({
  customCategories: [
    { name: 'goals', description: 'Race targets and training objectives' },
    { name: 'constraints', description: 'Injuries, limitations, recovery needs' },
    { name: 'preferences', description: 'Training style, surfaces, schedules' },
  ],
});
```

<Note>
**Categories vs Metadata:** Categories are AI-assigned by Mem0 based on content semantics. You define the palette, Mem0 picks which ones apply. If you need guaranteed tagging, use `metadata` instead.
</Note>

Now when you add memories, Mem0 automatically assigns the appropriate categories:

```typescript
// Add goal - Mem0 automatically tags it as "goals"
await mem0Client.add(
  [{ role: 'user', content: "Sub-4 marathon is my A-race" }],
  { userId: 'max' }
);

// Add constraint - Mem0 automatically tags it as "constraints"
await mem0Client.add(
  [{ role: 'user', content: 'My right knee flares up on downhills' }],
  { userId: 'max' }
);
```

Mem0 reads the content and intelligently picks which categories apply. You define the palette, it handles the tagging.

**Important:** You cannot force specific categories. Mem0's platform decides which categories are relevant based on content. If you need to force-tag something, use `metadata` instead:

```typescript
// Force tag using metadata (not categories)
await mem0Client.add(
  [{ role: 'user', content: 'Some workout note' }],
  { userId: 'max', metadata: { workout_type: 'speed', forced_tag: 'custom_label' } }
);
```

### Filtering by Category

Retrieve just constraints for workout planning:

```typescript
const constraints = await mem0Client.search(
  'injury concerns',
  { userId: 'max', filters: { categories: { in: ['constraints'] } } }
);
console.log(constraints.results.map((m: any) => m.memory));
// Output: ["Max's right knee flares up on downhills"]
```

Ray can plan workouts that avoid aggravating Max's knee, without pulling in race goals or other unrelated memories.

---

## Filtering What Gets Stored

### The Problem

Run the basic loop for a week and check what's stored:

```typescript
const memories = await mem0Client.getAll({ filters: { AND: [{ user_id: 'max' }] } });
console.log(memories.results.map((m: any) => m.memory));
// Output: ["Max wants to run marathon under 4 hours", "hey", "lol ok", "cool thanks", "gtg bye"]
```

<Warning>
Without filters, Mem0 stores everything—greetings, filler, and casual chat. This pollutes retrieval: instead of pulling "marathon goal," you get "lol ok." Set custom instructions to keep memory clean.
</Warning>

Noise. Greetings and filler clutter the memory.

### Custom Instructions

Tell Mem0 what matters:

```typescript
await mem0Client.project.update({
  customInstructions: `
Extract from running coach conversations:
- Training goals and race targets
- Physical constraints or injuries
- Training preferences (time of day, surfaces, weather)
- Progress milestones

Exclude:
- Greetings and filler
- Casual chatter
- Hypotheticals unless planning related
`,
});
```

Now chat again:

```typescript
await chat("hey how's it going", 'max');
await chat('I prefer trail running over roads', 'max');

const filtered = await mem0Client.getAll({ filters: { AND: [{ user_id: 'max' }] } });
console.log(filtered.results.map((m: any) => m.memory));
// Output: ["Max wants to run marathon under 4 hours", "Max prefers trail running over roads"]
```

<Info>
**Expected output:** Only 2 memories stored—the marathon goal and trail preference. The greeting "hey how's it going" was filtered out automatically. Custom instructions are working.
</Info>

Only meaningful facts. Filler gets dropped automatically.

---

---

## Agent Memory for Personality

### Why Agents Need Memory Too

Max prefers direct feedback, not motivational fluff. Ray needs to remember how to communicate - that's agent memory, separate from user memory.

Store agent personality:

```typescript
await mem0Client.add(
  [{ role: 'system', content: 'Max wants direct, data-driven feedback. Skip motivational language.' }],
  { agentId: 'ray_coach' }
);
```

Retrieve agent style alongside user memories:

```typescript
// Get coach personality
const agentMemories = await mem0Client.search('coaching style', { agentId: 'ray_coach' });
// Output: ["Max wants direct, data-driven feedback. Skip motivational language."]

// Store conversations with agentId
await mem0Client.add([
  { role: 'user', content: "How'd my run look today?" },
  { role: 'assistant', content: 'Pace was 8:15/mile. Heart rate 152, zone 2.' },
], { userId: 'max', agentId: 'ray_coach' });
```

<Info>
**Expected behavior:** Ray's responses are now data-driven and direct. The agent memory stored the coaching style preference, so future responses adapt automatically without Max having to repeat his preference.
</Info>

No "Great job!" or "Keep it up!" - just data. Ray adapts to Max's preference.

---

## Managing Short-Term Context

### When to Store in Mem0

Don't send every single message to Mem0. Keep recent context in memory, let Mem0 handle the important long-term facts.

```typescript
// Store only meaningful exchanges in Mem0
await mem0Client.add([
  { role: 'user', content: 'I want to run a marathon' },
  { role: 'assistant', content: "Let's build a training plan" },
], { userId: 'max' });

// Skip storing filler
// "hey" → don't store
// "cool thanks" → don't store

// Or rely on customInstructions to filter automatically
```

Last 10 messages in your app's buffer. Important facts in Mem0. Faster, cheaper, still works.

---

## Time-Bound Memories

### Auto-Expiring Facts

Max tweaks his ankle. It'll heal in two weeks - the memory should expire too.

```typescript
const expiration = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

await mem0Client.add(
  [{ role: 'user', content: 'Rolled my left ankle, needs rest' }],
  { userId: 'max', expirationDate: expiration }
);
```

In 14 days, this memory disappears automatically. Ray stops asking about the ankle.

---

## Putting It All Together

Here's the Mem0 setup combining everything:

```typescript
import MemoryClient from 'mem0ai';

const mem0Client = new MemoryClient({ apiKey: process.env.MEM0_API_KEY! });

// Configure memory filtering and categories
await mem0Client.project.update({
  customInstructions: 'Extract: goals, constraints, preferences, progress\nExclude: greetings, filler, casual chat',
  customCategories: [
    { name: 'goals', description: 'Training targets' },
    { name: 'constraints', description: 'Injuries and limitations' },
    { name: 'preferences', description: 'Training style' },
  ],
});
```

**Week 1 - Store goals and preferences:**

```typescript
await mem0Client.add([
  { role: 'user', content: 'I want to run a sub-4 marathon' },
  { role: 'assistant', content: "Got it. Let's build a training plan." },
], { userId: 'max', agentId: 'ray', categories: ['goals'] });

await mem0Client.add(
  [{ role: 'user', content: 'I prefer trail running over roads' }],
  { userId: 'max', categories: ['preferences'] }
);
```

**Week 3 - Temporary injury with expiration:**

```typescript
const expiration = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
await mem0Client.add(
  [{ role: 'user', content: 'Rolled ankle, need light workouts' }],
  { userId: 'max', categories: ['constraints'], expirationDate: expiration }
);
```

**Retrieve for context:**

```typescript
const memories = await mem0Client.search('training plan', { userId: 'max', limit: 5 });
// Gets: marathon goal, trail preference, ankle injury (if still valid)
```

Ray remembers goals, preferences, and personality. Handles temporary injuries. Works across sessions.

---

## Common Production Patterns

### Episodic Stories with run_id

Training for Boston is different from training for New York. Separate the memory threads:

```typescript
await mem0Client.add(messages, { userId: 'max', runId: 'boston-2025' });
await mem0Client.add(messages, { userId: 'max', runId: 'nyc-2025' });

// Retrieve only Boston memories
const bostonMemories = await mem0Client.search('training plan', { userId: 'max', runId: 'boston-2025' });
```

Each race gets its own episodic boundary. No cross-contamination.

### Importing Historical Data

Max has 6 months of training logs to backfill:

```typescript
const oldLogs = [
  [{ role: 'user', content: 'Completed 20-mile long run' }],
  [{ role: 'user', content: 'Hit 8:00 pace on tempo run' }],
];

for (const log of oldLogs) {
  await mem0Client.add(log, { userId: 'max' });
}
```

### Handling Contradictions

Max changes his goal from sub-4 to sub-3:45:

```typescript
// Find the old memory
const allMemories = await mem0Client.getAll({ filters: { AND: [{ user_id: 'max' }] } });
const goalMemory = allMemories.results.find((m: any) => m.memory.includes('sub-4'));

// Update it
if (goalMemory) {
  await mem0Client.update(goalMemory.id, 'Max wants to run sub-3:45 marathon');
}
```

Update instead of creating duplicates.

### Multiple Agents

Max works with Ray for running and Jordan for strength training:

```typescript
await chat('easy run today', 'max', 'ray');
await chat('leg day workout', 'max', 'jordan');
```

Each coach maintains separate personality memory while sharing user context.

### Filtering by Date

Prioritize recent training over old data:

```typescript
const recent = await mem0Client.search(
  'training progress',
  { userId: 'max', filters: { created_at: { gte: '2025-10-01' } } }
);
```

### Metadata Tagging

Tag workouts by type:

```typescript
await mem0Client.add(
  [{ role: 'user', content: '10x400m intervals' }],
  { userId: 'max', metadata: { workout_type: 'speed', intensity: 'high' } }
);

// Later, find all speed workouts
const speedSessions = await mem0Client.search(
  'speed work',
  { userId: 'max', filters: { metadata: { workout_type: 'speed' } } }
);
```

### Pruning Old Memories

Delete irrelevant memories:

```typescript
await mem0Client.delete('mem_xyz');

// Or clear an entire runId
await mem0Client.deleteAll({ userId: 'max', runId: 'old-training-cycle' });
```

---

## What You Built

A companion that:

- **Persists across sessions** - Mem0 storage
- **Filters noise** - custom instructions
- **Organizes by type** - categories
- **Adapts personality** - **`agent_id`**
- **Stays fast** - short-term buffer
- **Handles temporal facts** - expiration
- **Scales to production** - batching, metadata, pruning

This pattern works for any companion: fitness coaches, tutors, roleplay characters, therapy bots, creative writing partners.

---

<Tip>
Start with 2-3 categories max (e.g., goals, constraints, preferences). More categories dilute tagging accuracy. You can always add more later after seeing what Mem0 extracts.
</Tip>

---

## Production Checklist

Before launching:

- Set custom instructions for your domain
- Define 2-3 categories (goals, constraints, preferences)
- Add expiration strategy for time-bound facts
- Implement error handling for API calls
- Monitor memory quality in Mem0 dashboard
- Clear test data from production project

---

<CardGroup cols={2}>
  <Card title="Partition Memories by Entity" icon="layers" href="/cookbooks/essentials/entity-partitioning-playbook">
    Keep companions from leaking context by combining user, agent, and session scopes.
  </Card>
  <Card title="Tag Support Memories" icon="tag" href="/cookbooks/essentials/tagging-and-organizing-memories">
    Organize customer context to keep assistants responsive at scale.
  </Card>
</CardGroup>
