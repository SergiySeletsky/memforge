---
title: Tag and Organize Memories
description: "Let Mem0 auto-categorize support data so teams retrieve the right facts fast."
---


When you have large volumes of memory data, sorting it during post-processing becomes difficult. What if your memory store understood the importance of creating tags and buckets without a lot of effort?

Mem0 handles this for you by providing the flexibility to organize memories with custom categories. This cookbook shows you how to tag and organize memories for a customer support platform.

---

## Setup

```typescript
import MemoryClient from 'mem0ai';

const client = new MemoryClient({ apiKey: 'your-api-key' });
```

<Note>
Define custom categories at the **project level** with `client.project.update()` before adding memories. Categories apply to all future memories—Mem0 auto-assigns them based on content semantics.
</Note>

---

## The Problem

Without categories, all memories sit in one undifferentiated bucket. Support agents waste time searching through everything to find billing issues, account details, or past tickets.

Let's see what happens without organization:

```typescript
// Joseph (support agent) stores various customer interactions
await client.add(
  'Maria called about her account password reset',
  { userId: 'maria' }
);

await client.add(
  "Maria was charged twice for last month's subscription",
  { userId: 'maria' }
);

await client.add(
  'Maria wants to upgrade to the premium plan',
  { userId: 'maria' }
);

// Now try to find just billing issues
const allMemories = await client.getAll({ filters: { userId: 'maria' } });
console.log(`Total memories: ${allMemories['results'].length}`);

for (const memory of allMemories['results']) {
  console.log(`- ${memory['memory']}`);
}
```

**Output:**

```
Total memories: 3
- Maria called about her account password reset
- Maria was charged twice for last month's subscription
- Maria wants to upgrade to the premium plan

```

<Warning>
Without categories, agents waste time reading through everything. For a customer with 100 memories, finding one billing issue means scanning all 100. Categories let you filter to exactly what you need—billing issues only, no password resets or feedback mixed in.
</Warning>

Everything is mixed together. Support agents have to read through all memories to find what they need.

---

## Custom Categories

Define categories that match how your support team thinks about customer issues:

```typescript
const customCategories = [
  { support_tickets: 'Customer issues and resolutions' },
  { account_info: 'Account details and preferences' },
  { billing: 'Payment history and billing questions' },
  { product_feedback: 'Feature requests and feedback' },
];

// Configure via Mem0 dashboard: app.mem0.ai/settings
// await (client as any).project?.update({ customCategories });
```

<Tip>
Start with 3-5 clear categories that match how your team thinks. Too many categories dilute auto-tagging accuracy. Add more later if needed—it's easier to expand than to fix over-complicated classification.
</Tip>

These categories are now available project-wide. Every memory can be tagged with one or more categories.

---

## Tagging Memories

Once categories are defined at the project level, Mem0 automatically assigns them based on content:

```typescript
// Billing issue - automatically tagged as "billing"
await client.add(
  "Maria was charged twice for last month's subscription",
  { userId: 'maria', metadata: { priority: 'high', source: 'phone_call' } }
);

// Account update - automatically tagged as "account_info"
await client.add(
  'Maria changed her email to maria.new@example.com',
  { userId: 'maria', metadata: { source: 'web_portal' } }
);

// Product feedback - automatically tagged as "product_feedback"
await client.add(
  'Maria requested a dark mode feature for the dashboard',
  { userId: 'maria', metadata: { source: 'chat' } }
);
```

Mem0 reads the content and intelligently assigns the appropriate categories. You don't manually tag - the platform does it for you based on the category definitions.

---

## Retrieving by Category

Filter memories by category to find exactly what you need:

```typescript
// Joseph needs to pull all billing issues for audit
const billingIssues = await client.getAll({
  filters: {
    AND: [
      { userId: 'maria' },
      { categories: { in: ['billing'] } }
    ]
  }
});

console.log('Billing issues:');
for (const memory of billingIssues['results']) {
  console.log(`- ${memory['memory']}`);
}
```

**Output:**

```
Billing issues:
- Maria was charged twice for last month's subscription

```

<Info icon="check">
**Expected output:** Only the billing issue returned—no password reset, no upgrade request. Category filtering worked. Joseph can audit billing without reading through unrelated support tickets.
</Info>

Only billing-related memories are returned. No need to filter through account updates or feedback.

You can also retrieve multiple categories:

```typescript
// Get both account info and billing
const accountAndBilling = await client.getAll({
  filters: {
    AND: [
      { userId: 'maria' },
      { categories: { in: ['account_info', 'billing'] } }
    ]
  }
});

for (const memory of accountAndBilling['results']) {
  console.log(`[${memory['categories'][0]}] ${memory['memory']}`);
}
```

**Output:**

```
[account_info] Maria changed her email to maria.new@example.com
[billing] Maria was charged twice for last month's subscription

```

---

## Updating Categories

Categories are automatically assigned based on content. To trigger re-categorization, update the memory content:

```typescript
// Find memories that need re-categorization
const needsUpdate = await client.getAll({
  filters: {
    AND: [
      { userId: 'maria' },
      { categories: { in: ['misc'] } }
    ]
  }
});

// Update memory content to trigger re-categorization
for (const memory of needsUpdate['results']) {
  await client.update(
    memory['id'],
    memory['memory']  // Re-process with current category definitions
  );
}
```

When you update a memory, Mem0 re-analyzes it against your current category definitions. This is useful when you introduce new categories or refine category descriptions.

---

## What You Built

A customer support platform with intelligent memory organization:

- **Project-wide categories** - Support tickets, billing, account info, and product feedback auto-classified
- **Automatic tagging** - Mem0 assigns categories based on content semantics, no manual tagging
- **Filtered retrieval** - Pull only billing issues or only account updates using `categories: {in: [...]}`
- **Re-categorization** - Update memory content to trigger re-analysis against new category definitions
- **Multi-category support** - Memories can belong to multiple categories when appropriate

This pattern scales from 10 customers to 10,000 without degrading retrieval speed.

---

## Summary

Categories make retrieval faster and compliance easier. Define 3-5 clear categories with `client.project.update()`, let Mem0 auto-assign them based on content, then filter with `categories: {in: [...]}` to pull exactly what you need.

Instead of searching through everything, agents jump directly to the information type they need—billing issues, account details, or support tickets.

<CardGroup cols={2}>
  <Card title="Control Memory Ingestion" icon="filter" href="/cookbooks/essentials/controlling-memory-ingestion">
    Keep categories meaningful by filtering noise before it lands in storage.
  </Card>
  <Card title="Export Tagged Memories" icon="download" href="/cookbooks/essentials/exporting-memories">
    Use categories to drive audits, migrations, and compliance reports.
  </Card>
</CardGroup>
