---
title: Langchain Tools
description: 'Integrate Mem0 with LangChain.js tools to enable AI agents to store, search, and manage memories through structured interfaces'
---

## Overview

Mem0 provides tools for storing, searching, and retrieving memories, enabling agents to maintain context and learn from past interactions. These are built as LangChain.js tools, making them easily integrable with any AI agent.

## Installation

```bash
npm install @langchain/core mem0ai zod
```

## Authentication

```ts
import { DynamicStructuredTool } from "@langchain/core/tools";
import MemoryClient from "mem0ai";
import { z } from "zod";

const client = new MemoryClient({
  apiKey: process.env.MEM0_API_KEY,
});
```

## Available Tools

### 1. ADD Memory Tool

Stores new memories with associated metadata.

```ts
const addMemoryTool = new DynamicStructuredTool({
  name: "add_memory",
  description: "Add new messages to memory with associated metadata",
  schema: z.object({
    messages: z.array(
      z.object({
        role: z.string().describe("Role of the message sender (user or assistant)"),
        content: z.string().describe("Content of the message"),
      })
    ),
    userId: z.string().describe("ID of the user associated with these messages"),
    metadata: z.record(z.any()).optional().describe("Additional metadata"),
  }),
  func: async ({ messages, userId, metadata }) => {
    const result = await client.add(messages, { userId, metadata });
    return JSON.stringify(result);
  },
});
```

#### Example Usage

```ts
const addResult = await addMemoryTool.invoke({
  messages: [
    { role: "user", content: "Hi, I'm Alex. I'm a vegetarian and I'm allergic to nuts." },
    { role: "assistant", content: "Hello Alex! I've noted that you're a vegetarian and have a nut allergy." },
  ],
  userId: "alex",
  metadata: { food: "vegan" },
});
```

```json Output
{
  "results": [
    { "memory": "Name is Alex", "event": "ADD" },
    { "memory": "Is a vegetarian", "event": "ADD" },
    { "memory": "Is allergic to nuts", "event": "ADD" }
  ]
}
```

### 2. SEARCH Memory Tool

Queries stored memories using natural language and advanced filters.

```ts
const searchMemoryTool = new DynamicStructuredTool({
  name: "search_memory",
  description: "Search through memories with a query and filters",
  schema: z.object({
    query: z.string().describe("The search query string"),
    filters: z.record(z.any()).describe("Filters to apply to the search"),
  }),
  func: async ({ query, filters }) => {
    const result = await client.search(query, { filters });
    return JSON.stringify(result);
  },
});
```

#### Example Usage

```ts
const searchResult = await searchMemoryTool.invoke({
  query: "what is my name?",
  filters: {
    AND: [
      { user_id: "alex" },
      { created_at: { gte: "2024-07-20", lte: "2024-12-10" } },
    ],
  },
});
```

```json Output
[
  {
    "id": "1a75e827-7eca-45ea-8c5c-cfd43299f061",
    "memory": "Name is Alex",
    "user_id": "alex",
    "score": 0.381
  }
]
```

### 3. GET_ALL Memory Tool

Retrieves all memories matching specified criteria with pagination support.

```ts
const getAllMemoryTool = new DynamicStructuredTool({
  name: "get_all_memory",
  description: "Retrieve all memories matching specified filters",
  schema: z.object({
    filters: z.record(z.any()).describe("Filters to apply to the retrieval"),
    page: z.number().optional().default(1).describe("Page number for pagination"),
    pageSize: z.number().optional().default(50).describe("Number of items per page"),
  }),
  func: async ({ filters, page, pageSize }) => {
    const result = await client.getAll({ filters, page, pageSize });
    return JSON.stringify(result);
  },
});
```

#### Example Usage

```ts
const getAllResult = await getAllMemoryTool.invoke({
  filters: {
    AND: [
      { user_id: "alex" },
      { created_at: { gte: "2024-07-01", lte: "2024-12-31" } },
    ],
  },
  page: 1,
  pageSize: 50,
});
```

## Integration with AI Agents

All tools are implemented as `DynamicStructuredTool` instances, making them compatible with any LangChain.js agent:

```ts
import { ChatOpenAI } from "@langchain/openai";
import { createOpenAIFunctionsAgent, AgentExecutor } from "langchain/agents";
import { ChatPromptTemplate, MessagesPlaceholder } from "@langchain/core/prompts";

const llm = new ChatOpenAI({ modelName: "gpt-4o-mini", temperature: 0 });
const tools = [addMemoryTool, searchMemoryTool, getAllMemoryTool];

const prompt = ChatPromptTemplate.fromMessages([
  ["system", "You are a helpful assistant with memory capabilities."],
  new MessagesPlaceholder("chat_history"),
  ["human", "{input}"],
  new MessagesPlaceholder("agent_scratchpad"),
]);

const agent = await createOpenAIFunctionsAgent({ llm, tools, prompt });
const executor = new AgentExecutor({ agent, tools });

const result = await executor.invoke({ input: "Remember that I prefer window seats on flights", chat_history: [] });
console.log(result.output);
```

<CardGroup cols={2}>
  <Card title="LangChain Integration" icon="link" href="/integrations/langchain">
    Build conversational agents with LangChain and Mem0
  </Card>
  <Card title="Vercel AI SDK" icon="bolt" href="/integrations/vercel-ai-sdk">
    Add memory to Vercel AI SDK applications
  </Card>
</CardGroup>
