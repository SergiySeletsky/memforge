---
title: OpenAI Agents SDK
---

Integrate [**Mem0**](https://github.com/mem0ai/mem0) with [OpenAI Agents SDK](https://openai.github.io/openai-agents-js/), a lightweight framework for building multi-agent workflows in TypeScript. This integration enables agents to access persistent memory across conversations, enhancing context retention and personalization.

## Overview

1. Store and retrieve memories from Mem0 within OpenAI agents
2. Multi-agent workflows with shared memory
3. Retrieve relevant memories for past conversations
4. Personalized responses based on user history

## Prerequisites

Install the required packages:

```bash
npm install @openai/agents mem0ai
```

You'll need valid API keys:
- [Mem0 API Key](https://app.mem0.ai/dashboard/api-keys)
- [OpenAI API Key](https://platform.openai.com/api-keys)

## Basic Integration Example

```ts
import { Agent, run, tool } from "@openai/agents";
import MemoryClient from "mem0ai";
import { z } from "zod";

const mem0 = new MemoryClient({ apiKey: process.env.MEM0_API_KEY });

// Define memory tools for the agent
const searchMemory = tool({
  name: "search_memory",
  description: "Search through past conversations and memories",
  parameters: z.object({
    query: z.string(),
    userId: z.string(),
  }),
  execute: async ({ query, userId }) => {
    const memories = await mem0.search(query, { userId, limit: 3 });
    if (memories?.results?.length) {
      return memories.results.map((m: any) => `- ${m.memory}`).join("\n");
    }
    return "No relevant memories found.";
  },
});

const saveMemory = tool({
  name: "save_memory",
  description: "Save important information to memory",
  parameters: z.object({
    content: z.string(),
    userId: z.string(),
  }),
  execute: async ({ content, userId }) => {
    await mem0.add([{ role: "user", content }], { userId });
    return "Information saved to memory.";
  },
});

// Create agent with memory capabilities
const agent = new Agent({
  name: "Personal Assistant",
  instructions: `You are a helpful personal assistant with memory capabilities.
    Use the search_memory tool to recall past conversations and user preferences.
    Use the save_memory tool to store important information about the user.
    Always personalize your responses based on available memory.`,
  tools: [searchMemory, saveMemory],
  model: "gpt-4.1-nano-2025-04-14",
});

async function chatWithAgent(userInput: string, userId: string): Promise<string> {
  const result = await run(agent, userInput);
  return result.finalOutput ?? "";
}

// Example usage
const response1 = await chatWithAgent(
  "I love Italian food and I'm planning a trip to Rome next month",
  "alice"
);
console.log(response1);

const response2 = await chatWithAgent(
  "Give me some recommendations for food",
  "alice"
);
console.log(response2);
```

## Multi-Agent Workflow with Handoffs

Create multiple specialized agents with proper handoffs and shared memory:

```ts
import { Agent, run, tool, handoff } from "@openai/agents";
import MemoryClient from "mem0ai";
import { z } from "zod";

const mem0 = new MemoryClient({ apiKey: process.env.MEM0_API_KEY });

const searchMemoryTool = tool({
  name: "search_memory",
  description: "Search for relevant past memories",
  parameters: z.object({ query: z.string(), userId: z.string() }),
  execute: async ({ query, userId }) => {
    const memories = await mem0.search(query, { userId, limit: 3 });
    return memories?.results?.map((m: any) => m.memory).join("\n") ?? "No memories found.";
  },
});

const saveMemoryTool = tool({
  name: "save_memory",
  description: "Save important information to memory",
  parameters: z.object({ content: z.string(), userId: z.string() }),
  execute: async ({ content, userId }) => {
    await mem0.add([{ role: "user", content }], { userId });
    return "Saved to memory.";
  },
});

const travelAgent = new Agent({
  name: "Travel Planner",
  instructions: "You are a travel planning specialist. Use search_memory to understand user preferences before making recommendations, and save_memory to store important details.",
  tools: [searchMemoryTool, saveMemoryTool],
  model: "gpt-4.1-nano-2025-04-14",
});

const healthAgent = new Agent({
  name: "Health Advisor",
  instructions: "You are a health and wellness advisor. Use search_memory to understand user health goals and save_memory to log relevant information.",
  tools: [searchMemoryTool, saveMemoryTool],
  model: "gpt-4.1-nano-2025-04-14",
});

const triageAgent = new Agent({
  name: "Personal Assistant",
  instructions: "Route travel questions to the Travel Planner and health questions to the Health Advisor. Handle general questions directly.",
  handoffs: [travelAgent, healthAgent],
  tools: [searchMemoryTool, saveMemoryTool],
  model: "gpt-4.1-nano-2025-04-14",
});

const response = await run(triageAgent, "Plan a healthy meal for my Italy trip");
console.log(response.finalOutput);
```

## Key Features

### 1. Automatic Memory Integration
- **Tool-Based Memory**: Agents use function tools to search and save memories
- **Conversation Storage**: All interactions are automatically stored
- **Context Retrieval**: Agents can access relevant past conversations

### 2. Multi-Agent Memory Sharing
- **Shared Context**: Multiple agents access the same memory store
- **Specialized Agents**: Create domain-specific agents with shared memory
- **Seamless Handoffs**: Agents maintain context across handoffs

### 3. Flexible Memory Operations
- **Retrieve Capabilities**: Retrieve relevant memories from previous conversations
- **User Segmentation**: Organize memories by user ID
- **Memory Management**: Built-in tools for saving and retrieving information

<CardGroup cols={2}>
  <Card title="OpenAI Tool Calls Cookbook" icon="wrench" href="/cookbooks/integrations/openai-tool-calls">
    Learn how to integrate Mem0 with OpenAI function calling
  </Card>
  <Card title="Agents SDK Tool Cookbook" icon="cube" href="/cookbooks/integrations/agents-sdk-tool">
    Build agents with OpenAI SDK tools
  </Card>
</CardGroup>
