---
title: Livekit
---

This guide demonstrates how to create a memory-enabled voice assistant using LiveKit, OpenAI, and Mem0, focusing on building an intelligent, context-aware travel planning agent.

## Prerequisites

1. Install LiveKit Agents for Node.js:
```bash
npm install @livekit/agents @livekit/agents-plugin-openai @livekit/agents-plugin-deepgram @livekit/agents-plugin-silero dotenv
```

2. Install Mem0 SDK:
```bash
npm install mem0ai
```

3. Set up your API keys in a `.env` file:
```sh
LIVEKIT_URL=your_livekit_url
LIVEKIT_API_KEY=your_livekit_api_key
LIVEKIT_API_SECRET=your_livekit_api_secret
DEEPGRAM_API_KEY=your_deepgram_api_key
MEM0_API_KEY=your_mem0_api_key
OPENAI_API_KEY=your_openai_api_key
```

## Code Breakdown

### 1. Setting Up Dependencies and Environment

```ts
import "dotenv/config";
import { WorkerOptions, defineAgent, cli, AgentContext } from "@livekit/agents";
import { openai, deepgram, silero } from "@livekit/agents-plugins";
import MemoryClient from "mem0ai";

const RAG_USER_ID = "livekit-mem0";
const mem0Client = new MemoryClient({ apiKey: process.env.MEM0_API_KEY });
```

### 2. Agent Definition with Memory Integration

```ts
const travelAgent = defineAgent({
  name: "George",
  instructions: `You are a helpful voice assistant and travel guide named George.
    You help users plan their dream trips — work retreats, family vacations, or solo adventures.
    You remember past interactions and use them to inform your answers.
    Use semantic memory retrieval to provide contextually relevant responses.`,

  async onUserInput(ctx: AgentContext, userMessage: string): Promise<void> {
    // 1. Persist the user message in Mem0
    try {
      await mem0Client.add(
        [{ role: "user", content: userMessage }],
        { userId: RAG_USER_ID }
      );
    } catch (e) {
      console.warn("Failed to store user message in Mem0:", e);
    }

    // 2. Retrieve relevant context via semantic search
    let contextInjection = "";
    try {
      const searchResults = await mem0Client.search(userMessage, {
        userId: RAG_USER_ID,
      });
      const results = searchResults?.results ?? [];
      if (results.length > 0) {
        const parts = results
          .map((r: any) => r.memory ?? r.text)
          .filter(Boolean)
          .map((text: string) => `- ${text}`);
        if (parts.length) {
          contextInjection = `\n\nRelevant past context:\n${parts.join("\n")}`;
        }
      }
    } catch (e) {
      console.warn("Failed to retrieve RAG context from Mem0:", e);
    }

    // 3. Augment the system prompt with retrieved context then generate reply
    await ctx.say(`${contextInjection ? `[Context: ${contextInjection}]` : ""}`);
  },
});
```

### 3. Entrypoint and Session Setup

```ts
async function entrypoint(ctx: AgentContext) {
  const session = await ctx.createSession({
    stt: deepgram.STT(),
    llm: openai.LLM({ model: "gpt-4.1-nano-2025-04-14" }),
    tts: openai.TTS({ voice: "ash" }),
    vad: silero.VAD(),
    agent: travelAgent,
  });

  await session.say(
    "Hello! I'm George, your travel guide. How can I help you plan your next adventure?"
  );

  await session.run();
}

cli.runApp(new WorkerOptions({ agent: entrypoint }));
```

## Running the Example

1. Install all required dependencies.
2. Set up your `.env` file with the necessary API keys.
3. Ensure your audio setup is configured.
4. Run the script:
```bash
node --import=tsx mem0-livekit-voice-agent.ts start
```
Or in console mode:
```bash
node --import=tsx mem0-livekit-voice-agent.ts console
```
5. After the script starts, interact with the voice agent using [LiveKit's Agent Playground](https://agents-playground.livekit.io/).

## Key Features

1. **Semantic Memory Retrieval**: Uses Mem0 to store and retrieve contextually relevant memories.
2. **Voice Interaction**: Leverages LiveKit for voice communication with turn detection.
3. **Intelligent Context Management**: Augments conversations with past interactions.
4. **Travel Planning Specialization**: Focused on creating a helpful travel guide assistant.

## Best Practices for Voice Agents with Memory

1. **Context Preservation**: Store enough context with each memory for effective retrieval.
2. **Privacy Considerations**: Implement secure memory management.
3. **Relevant Memory Filtering**: Use semantic search to retrieve only the most relevant memories.
4. **Error Handling**: Implement robust error handling for memory operations.

<CardGroup cols={2}>
  <Card title="ElevenLabs Integration" icon="volume" href="/integrations/elevenlabs">
    Build conversational voice agents with ElevenLabs
  </Card>
  <Card title="Vercel AI SDK" icon="bolt" href="/integrations/vercel-ai-sdk">
    Add memory to streaming AI applications
  </Card>
</CardGroup>
